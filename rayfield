local HttpService = game:GetService("HttpService")

getgenv().Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
getgenv().SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
getgenv().InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

getgenv().Window = Fluent:CreateWindow({
    Title = "RF24 | Hydra",
    SubTitle = "Premium",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = false, 
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.RightShift
})

local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("StarterGui")
local player = game:GetService("Players").LocalPlayer
local balls = {}
local lastrefreshtime = os.time()
local targetColor = BrickColor.new(Color3.fromRGB(237, 234, 234))
local reachEnabled = false
local reach = 5

function refreshballs(force)
    if force == false then
        if lastrefreshtime + 2 > os.time() then print("too early") return end
    end
    lastrefreshtime = os.time()
    table.clear(balls)
    for i,v in pairs(workspace:GetDescendants()) do
        if v:IsA("BasePart") and v.CanCollide == true and v.Transparency == 1 and v.BrickColor == targetColor then
            task.wait()
            table.insert(balls,v)
        end
    end
end

local gkReachEnabled = false
local gkReach = 5

UserInputService.InputBegan:Connect(function(i, gameProcessedEvent)
    if i.KeyCode == Enum.KeyCode.W or i.KeyCode == Enum.KeyCode.A or i.KeyCode == Enum.KeyCode.S or i.KeyCode == Enum.KeyCode.D or i.KeyCode == Enum.KeyCode.Space then
        return
    end
    if gameProcessedEvent == false then
        refreshballs(false)
        local bodyParts = {}
        if reachEnabled then
            bodyParts = {player.Character["RightFoot"], player.Character["LeftFoot"]}
        end
        if gkReachEnabled then
            bodyParts = {player.Character["RightHand"], player.Character["LeftHand"]}
        end
        for i,c in pairs(bodyParts) do
            for i,v in pairs(c:GetDescendants()) do
                if v.Name == "TouchInterest" and v.Parent then
                    for i,e in pairs(balls) do
                        if (e.Position - c.Position).magnitude < (reachEnabled and reach or gkReach) then
                            firetouchinterest(e,c,0)
                            firetouchinterest(e,c,1)
                            break
                        end
                    end
                end
            end
        end
    end
end)

local Main = {
    Main = Window:AddTab({ Title = "Main", Icon = "" }),
}

local Misc = {
    Main = Window:AddTab({ Title = "Misc", Icon = "" }),
}

local Game = {
    Main = Window:AddTab({ Title = "Game", Icon = "" }),
}

local Character = {
    Main = Window:AddTab({ Title = "Character", Icon = "" }),
}


local Teams = {
    Main = Window:AddTab({ Title = "Teams", Icon = "" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

local Options = Fluent.Options

function reduceLag()
    local decalsyeeted = true 
    local g = game
    local w = g.Workspace
    local l = g.Lighting
    local t = w.Terrain
    t.WaterWaveSize = 0
    t.WaterWaveSpeed = 0
    t.WaterReflectance = 0
    t.WaterTransparency = 0
    l.GlobalShadows = false
    l.FogEnd = 9e9
    l.Brightness = 0
    settings().Rendering.QualityLevel = "Level01"
    for i, v in pairs(g:GetDescendants()) do
        if v:IsA("Part") or v:IsA("Union") or v:IsA("CornerWedgePart") or v:IsA("TrussPart") then
            v.Material = "Plastic"
            v.Reflectance = 0
        elseif v:IsA("Decal") or v:IsA("Texture") and decalsyeeted then
            v.Transparency = 1
        elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
            v.Lifetime = NumberRange.new(0)
        elseif v:IsA("Explosion") then
            v.BlastPressure = 1
            v.BlastRadius = 1
        elseif v:IsA("Fire") or v:IsA("SpotLight") or v:IsA("Smoke") then
            v.Enabled = false
        elseif v:IsA("MeshPart") then
            v.Material = "Plastic"
            v.Reflectance = 0
            v.TextureID = 10385902758728957
        end
    end
    for i, e in pairs(l:GetChildren()) do
        if e:IsA("BlurEffect") or e:IsA("SunRaysEffect") or e:IsA("ColorCorrectionEffect") or e:IsA("BloomEffect") or e:IsA("DepthOfFieldEffect") then
            e.Enabled = false
        end
    end
end

function catch()
    local player = game:GetService("Players").LocalPlayer
    local function getBall()
        local targetColor = BrickColor.new(Color3.fromRGB(237, 234, 234))
        local ball = nil
        local distance = math.huge -- Start with a large distance
        for _, part in ipairs(workspace:GetDescendants()) do
            if part:IsA("BasePart") and part.CanCollide == true and part.Transparency == 1 and part.BrickColor == targetColor then
                local partPosition = part.Position
                local currentDistance = (partPosition - player.Character.HumanoidRootPart.Position).magnitude
                if currentDistance < distance then
                    ball = part
                    distance = currentDistance
                end
            end
        end
        return ball
    end
    
    local playerPosition = player.Character.HumanoidRootPart.Position
    
    local args = {
        [1] = 1000,
        [2] = "catch",
        [3] = {
            ["cframe"] = CFrame.new(playerPosition),
            ["ball"] = getBall()
        }
    }
    
    -- Ensure the ball is found before invoking the RemoteFunctions
if args[3]["ball"] then
    local sharedModule = game:GetService("ReplicatedStorage"):WaitForChild("network"):WaitForChild("Shared")
    local remoteFunctions = sharedModule:GetChildren()

    -- Invoke each RemoteFunction with the provided arguments
    for _, func in ipairs(remoteFunctions) do
        if func:IsA("RemoteFunction") then
            pcall(function()
                func:InvokeServer(unpack(args))
            end)
        end
    end
else
    warn("Ball not found.")
end
end

function drop()
local player = game:GetService("Players").LocalPlayer
local gameWorkspace = game.Workspace.game

local function getBaseParts(folder)
    local baseParts = {}
    for _, part in ipairs(folder:GetDescendants()) do
        if part:IsA("BasePart") then
            table.insert(baseParts, part)
        end
    end
    return baseParts
end

for _, folder in ipairs(gameWorkspace:GetChildren()) do
    if folder.Name:sub(1, 1):lower() == "i" or folder.Name:sub(1, 1):lower() == "l" then
        local baseParts = getBaseParts(folder)

        for _, part in ipairs(baseParts) do
            local args = {
                [1] = 1000,
                [2] = "drop",
                [3] = {
                    ["ball"] = part -- Use the base part found in the folder
                }
            }

            local sharedModule = game:GetService("ReplicatedStorage"):WaitForChild("network"):WaitForChild("Shared")
            local remoteFunctions = sharedModule:GetChildren()

            for _, func in ipairs(remoteFunctions) do
                if func:IsA("RemoteEvent") then
                    pcall(function()
                        func:FireServer(unpack(args))
                    end)
                end
            end
        end
    end
end
end

local function catch1()
    local function getBall()
        local targetColor = BrickColor.new(Color3.fromRGB(237, 234, 234))
        local ball = nil
        local distance = math.huge
        for _, part in ipairs(workspace:GetDescendants()) do
            if part:IsA("BasePart") and part.CanCollide == true and part.Transparency == 1 and part.BrickColor == targetColor then
                local partPosition = part.Position
                local currentDistance = (partPosition - player.Character.HumanoidRootPart.Position).magnitude
                if currentDistance < distance then
                    ball = part
                    distance = currentDistance
                end
            end
        end
        return ball
    end
    
    local playerPosition = player.Character.HumanoidRootPart.Position
    
    local args = {
        [1] = 1000,
        [2] = "catch",
        [3] = {
            ["cframe"] = CFrame.new(playerPosition),
            ["ball"] = getBall()
        }
    }
    
    while not args[3]["ball"] do
        wait(1)
        args[3]["ball"] = getBall()
    end

    local sharedModule = game:GetService("ReplicatedStorage"):WaitForChild("network"):WaitForChild("Shared")
    local remoteFunctions = sharedModule:GetChildren()

    for _, func in ipairs(remoteFunctions) do
        if func:IsA("RemoteFunction") then
            local success, error = pcall(function()
                func:InvokeServer(unpack(args))
            end)
            if success then
                print("Remote function invoked successfully.")
            else
                warn("Failed to invoke remote function: ", error)
            end
        end
    end
end

Fluent:Notify({
    Title = "Hydra",
    Content = "Auto Farm is in beta expect bugs.",
    Duration = 8
})

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local Toggle = Main.Main:AddToggle("MyToggle", {Title = "Auto Farm (BETA)", Default = false })
local player = Players.LocalPlayer
local isToggled = false
local home = Vector3.new(-1.6493651866912842, 0.7610451579093933, -352.9581604003906)
local away = Vector3.new(-1.9949278831481934, 0.7224336862564087, 355.56939697265625)

local function movePlayer(character, destination)
    local humanoid = character:WaitForChild("Humanoid")
    humanoid.WalkSpeed = 30

    local tweenInfo = TweenInfo.new(20, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)

    while isToggled do

        local playerPosition = character.HumanoidRootPart.Position
        local distance = (playerPosition - destination).Magnitude

        if distance >= 5 then
            local tween = TweenService:Create(character.HumanoidRootPart, tweenInfo, {CFrame = CFrame.new(destination)})
            tween:Play()
            tween.Completed:Connect(function()
                print("Tween completed.")
                if (character.HumanoidRootPart.Position - destination).Magnitude < 5 then
                    print("Player has reached the destination.")
                    catch1()
                end
            end)
            tween.Completed:Wait()
        else
            wait(1)
        end
    end
end


local function stopScript()
    print("Stopping script.")
    -- Add code here to stop any ongoing actions or processes
    -- For now, we'll just return to exit the loop
    return
end

Toggle:OnChanged(function()
    isToggled = Toggle.Value
    print("Toggle changed:", isToggled)
    if isToggled then
        local destination
        if player.Team then
            local teamName = player.Team.Name
            if teamName == "Away" or teamName == "Away GK" then
                destination = home
            elseif teamName == "Home" or teamName == "Home GK" then
                destination = away
            end
        end
        if destination then
            movePlayer(player.Character, destination)
        else
            warn("Destination not found.")
        end
    else
        stopScript() -- Stop the script if the toggle is turned off
    end
end)


local Toggle = Main.Main:AddToggle("MyToggle", {Title = "Reach", Default = false })
Toggle:OnChanged(function(Value)
    reachEnabled = Value
end)

local Slider = Main.Main:AddSlider("Slider", {
    Title = "Radius",
    Description = "",
    Default = 5,
    Min = 0,
    Max = 25,
    Rounding = 1,
    Callback = function(Value)
        reach = Value
    end
})

local Toggle = Main.Main:AddToggle("MyToggle", {Title = "GK Reach", Default = false })

Toggle:OnChanged(function(Value)
    gkReachEnabled = Value
end)

local Slider = Main.Main:AddSlider("Slider", {
    Title = "Radius",
    Description = "",
    Default = 5,
    Min = 0,
    Max = 25,
    Rounding = 1,
    Callback = function(Value)
        gkReach = Value
    end
})

local Toggle = Misc.Main:AddToggle("MyToggle", {Title = "Bypass VK (lvl 25+) | V2", Default = false })

Toggle:OnChanged(function(toggled)
    while toggled do
        coroutine.wrap(function()
            while toggled do
                local playerList = Players:GetPlayers()
                table.remove(playerList, table.find(playerList, localPlayer))

                if #playerList > 0 then
                    local randomPlayer = playerList[math.random(#playerList)]
                    game:GetService('Players'):Chat(":votekick " .. randomPlayer.Name)
                end

                wait(30) -- wait for 30 seconds before the next votekick
            end
        end)()

        coroutine.wrap(function()
            while toggled do
                local playerList = Players:GetPlayers()
                table.remove(playerList, table.find(playerList, localPlayer))

                if #playerList > 0 then
                    local randomPlayer = playerList[math.random(#playerList)]
                    game:GetService('Players'):Chat(":votekick " .. randomPlayer.Name)
                end

                wait(600) -- wait for 10 minutes before the next votekick
            end
        end)()

        break
    end
end)

local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local player = Players.LocalPlayer

local Toggle = Misc.Main:AddToggle("MyToggle", {Title = "Bypass VK (rejoins) | V1", Default = false })

local function rejoin()
    local Rejoin = coroutine.create(function()
        local Success, ErrorMessage = pcall(function()
            TeleportService:Teleport(game.PlaceId, LocalPlayer)
        end)

        if ErrorMessage and not Success then
            warn(ErrorMessage)
        end
    end)

    coroutine.resume(Rejoin)
end

Toggle:OnChanged(function(Value)

    if Value then
        player.OnKick:Connect(function()
            print("Player was kicked. Attempting to rejoin...")
            rejoin()
        end)
    end
end)

local RunService = game:GetService("RunService")

local Toggle = Misc.Main:AddToggle("MyToggle", {Title = "Delete Invisible Barriers", Default = false })
Toggle:OnChanged(function(Value)
    while Value do
        for i, player in pairs(game.Players:GetPlayers()) do
            for i, child in pairs(game.Workspace.game.debug:GetChildren()) do
                if child:IsA("Model") and string.find(child.Name, player.Name) then
                    child:Destroy()
                end
            end
        end
        RunService.RenderStepped:Wait() -- yield the script every frame
        if not Value then
            break 
        end
    end
end)

Misc.Main:AddButton({
    Title = "Bring Ball",
    Description = "Click this 2 times if u want to drop the ball",
    Callback = function()
        catch()
            drop()
    end
})

local Dropdown = Character.Main:AddDropdown("Dropdown", {
    Title = "Universal Scripts",
    Values = {"IY", "Fates Admin", "Secure Dex V3"},
    Multi = false,
    Default = nil,
})

Dropdown:OnChanged(function(Value)
    if Value == "IY" then
        loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
    elseif Value == "Fates Admin" then
        loadstring(game:HttpGet("https://raw.githubusercontent.com/fatesc/fates-admin/main/main.lua"))()
    elseif Value == "Secure Dex V3" then
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Babyhamsta/RBLX_Scripts/main/Universal/BypassedDarkDexV3.lua", true))()
    end
end)


Character.Main:AddButton({
    Title = "Pitch Teleporter",
    Description = "This is a gamepass feature this works by the game own function so you won't get detected",
    Callback = function()
       for _, v in pairs(game:GetService("ReplicatedStorage"):WaitForChild("network"):WaitForChild("Shared"):GetDescendants()) do
    if v:IsA("RemoteEvent") then
        v:FireServer(1000, "pitchTeleporter")
    end
end
end
})


local Slider = Character.Main:AddSlider("Slider", {
    Title = "FOV",
    Description = "",
    Default = 70,
    Min = 0,
    Max = 180,
    Rounding = 1,
    Callback = function(Value)
        game.Workspace.CurrentCamera.FieldOfView = Value
    end
})

Game.Main:AddButton({
    Title = "Reduce Lag",
    Description = "Removes some textures (this action is not revertable)",
    Callback = function()
        reduceLag()
    end
})

Game.Main:AddButton({
    Title = "Remove Snow",
    Description = "Removes Snow on Screen",
    Callback = function()
        game:GetService("Players").LocalPlayer.PlayerGui.main.overlay.Snow:Destroy()
    end
})

Game.Main:AddButton({
    Title = "Remove Rain",
    Description = "Removes Rain on Screen",
    Callback = function()
        game:GetService("Players").LocalPlayer.PlayerGui.main.overlay.Rain:Destroy()
    end
})

Game.Main:AddButton({
    Title = "Remove Blur",
    Description = "Removes Blurry Vision",
    Callback = function()
        game:GetService("Players").LocalPlayer.PlayerGui.main.overlay.vision:Destroy()
    end
})

Teams.Main:AddButton({
    Title = "Team Away",
    Description = "Switch to Away Team",
    Callback = function()
        local args = {
            [1] = 1000,
            [2] = "team",
            [3] = game:GetService("Teams"):WaitForChild("Away")  -- Use the "Away" team
        }

        local sharedModule = game:GetService("ReplicatedStorage"):WaitForChild("network"):WaitForChild("Shared")
        local remoteFunctions = sharedModule:GetChildren()

        -- Invoke each RemoteFunction with the provided arguments and print the response
        for _, func in ipairs(remoteFunctions) do
            if func:IsA("RemoteFunction") then
                local success, response = pcall(function()
                    return func:InvokeServer(unpack(args))
                end)
                if success then
                    print("Response from " .. func.Name .. ":", response)
                else
                    warn("Failed to invoke " .. func.Name .. ": " .. tostring(response))
                end
            end
        end
    end
})

Teams.Main:AddButton({
    Title = "Team Home",
    Description = "Switch to Home Team",
    Callback = function()
        local args = {
            [1] = 1000,
            [2] = "team",
            [3] = game:GetService("Teams"):WaitForChild("Home")  -- Use the "Home" team
        }

        local sharedModule = game:GetService("ReplicatedStorage"):WaitForChild("network"):WaitForChild("Shared")
        local remoteFunctions = sharedModule:GetChildren()

        -- Invoke each RemoteFunction with the provided arguments and print the response
        for _, func in ipairs(remoteFunctions) do
            if func:IsA("RemoteFunction") then
                local success, response = pcall(function()
                    return func:InvokeServer(unpack(args))
                end)
                if success then
                    print("Response from " .. func.Name .. ":", response)
                else
                    warn("Failed to invoke " .. func.Name .. ": " .. tostring(response))
                end
            end
        end
    end
})

Teams.Main:AddButton({
    Title = "Away GK",
    Description = "Switch to Away Team GK",
    Callback = function()
        local args = {
            [1] = 1000,
            [2] = "team",
            [3] = game:GetService("Teams"):WaitForChild("Away GK") 
        }

        local sharedModule = game:GetService("ReplicatedStorage"):WaitForChild("network"):WaitForChild("Shared")
        local remoteFunctions = sharedModule:GetChildren()
        for _, func in ipairs(remoteFunctions) do
            if func:IsA("RemoteFunction") then
                local success, response = pcall(function()
                    return func:InvokeServer(unpack(args))
                end)
                if success then
                    print("Response from " .. func.Name .. ":", response)
                else
                    warn("Failed to invoke " .. func.Name .. ": " .. tostring(response))
                end
            end
        end
    end
})

Teams.Main:AddButton({
    Title = "Home GK",
    Description = "Switch to Home Team GK",
    Callback = function()
        local args = {
            [1] = 1000,
            [2] = "team",
            [3] = game:GetService("Teams"):WaitForChild("Home GK")
        }

        local sharedModule = game:GetService("ReplicatedStorage"):WaitForChild("network"):WaitForChild("Shared")
        local remoteFunctions = sharedModule:GetChildren()

        for _, func in ipairs(remoteFunctions) do
            if func:IsA("RemoteFunction") then
                local success, response = pcall(function()
                    return func:InvokeServer(unpack(args))
                end)
                if success then
                    print("Response from " .. func.Name .. ":", response)
                else
                    warn("Failed to invoke " .. func.Name .. ": " .. tostring(response))
                end
            end
        end
    end
})


getgenv().SaveManager:SetLibrary(Fluent)
getgenv().InterfaceManager:SetLibrary(Fluent)

getgenv().SaveManager:IgnoreThemeSettings()
getgenv().SaveManager:SetIgnoreIndexes({})

getgenv().InterfaceManager:SetFolder("FluentScriptHub")
getgenv().SaveManager:SetFolder("FluentScriptHub/specific-game")

getgenv().InterfaceManager:BuildInterfaceSection(Teams.Settings)
getgenv().SaveManager:BuildConfigSection(Teams.Settings)

getgenv().Window:SelectTab(1)
getgenv().SaveManager:LoadAutoloadConfig()

















print("wsp")
